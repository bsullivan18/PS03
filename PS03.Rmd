---
title: 'STAT/MATH 495: Problem Set 03'
author: "Brenna Sullivan"
date: '17-09-26'
output:
  pdf_document:
    toc: yes
    toc_depth: '2'
  html_document:
    collapsed: no
    smooth_scroll: no
    toc: yes
    toc_depth: 2
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=8, fig.height=4.5)
library(mosaic)
library(broom)
# Load packages
library(tidyverse)
data1 <- read_csv("data/data1.csv")
data2 <- read_csv("data/data2.csv")
```


# Question

For both `data1` and `data2` tibbles (a tibble is a data frame with some
[metadata](https://blog.rstudio.com/2016/03/24/tibble-1-0-0#tibbles-vs-data-frames) attached:

* Find the splines model with the best out-of-sample predictive ability.
* Create a visualizaztion arguing why you chose this particular model.
* Create a visualizaztion of this model plotted over the given $(x_i, y_i)$ points for $i=1,\ldots,n=3000$.
* Give your estimate $\widehat{\sigma}$ of $\sigma$ where the noise component $\epsilon_i$ is distributed with mean 0 and  standard deviation $\sigma$.


# Data 1
```{r}
library(caret)
library(rpart)
head(data1)
```


```{r}
data1 <- read_csv("data/data1.csv")

library(rpart); library(caret)
model.single <- rpart(y ~ x, data = data1, method = "class")
predict.single <- predict(object = model.single, newdata = data1, type = "class")

k.folds <- function(k) {
    folds <- createFolds(data1$y, k = k, list = TRUE)
    for (i in 1:k) {
        model <- rpart(y ~ x, data = data1[folds[[i]],], method = "class")
        predictions <- predict(object = model, newdata = data1[-folds[[i]],], type = "class")
        accuracies.dt <- c(accuracies.dt, 
                           confusionMatrix(predictions, data1[-folds[[i]], ]$y)$overall[[1]])
    }
    accuracies.dt
}

set.seed(1)
accuracies.dt <- c()
accuracies.dt <- k.folds(5)
accuracies.dt

mean.accuracies <- mean(accuracies.dt)
sqrt(mean.accuracies)
```


# Data 2

```{r, echo=TRUE, warning=FALSE, message=FALSE}
head(data2)
```

```{r}
model_spline <- smooth.spline(data2$x, data2$y, df=11)


model_spline_data_frame <- model_spline %>%
  broom::augment()
ggplot(model_spline_data_frame, aes(x=x)) +
  geom_point(aes(y=y)) +
  geom_line(aes(y=.fitted), col="blue", size=1)


data2_A <- data2 %>% 
  sample_n(1500)
data2_B <- data2 %>% 
  anti_join(data2_A, by="ID")



new_x1 <- as.vector(data2_A$x)

output1 <- predict(model_spline, new_x1) %>% 
  tibble::as.tibble()
head(output)

MSE1 <- ((data2$y - output1$y)^2)
RMSE1 <- sqrt(mean(MSE1))

new_x2 <- as.vector(data2_B$x)

output2 <- predict(model_spline, new_x2) %>% 
  tibble::as.tibble()
head(output)

MSE2 <- ((data2$y - output2$y)^2)
RMSE2 <- sqrt(mean(MSE2))

(RMSE + RMSE2)/2
```



